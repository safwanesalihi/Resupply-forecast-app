from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Dict, Any, Optional
from datetime import date
import json
import os
import sys
import pandas as pd
from prophet import Prophet

# Add project root to path to import our custom modules
sys.path.append("/home/ubuntu/Resupply-forecast-app")

from app.api.v1.deps import get_db, get_current_user
from app.schemas.forecast import Forecast, ForecastGenerate
from app.db.models.forecast import Forecast as ForecastModel
from app.db.models.user import User
from app.services.forecast import ForecastService

router = APIRouter()

def run_forecast_generation(db: Session, product_ids: Optional[List[int]], periods: int, frequency: str):
    """Helper function to run forecast generation in the background."""
    forecast_service = ForecastService(db)
    try:
        results = forecast_service.generate_and_save_forecasts(
            product_ids=product_ids,
            periods=periods,
            frequency=frequency
        )
        print(f"Background forecast generation complete for {len(results)} products.")
    except Exception as e:
        print(f"Error during background forecast generation: {e}")
        # Add more robust error logging/handling here

@router.get("/", response_model=List[Forecast])
def get_forecasts(
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100,
    product_id: Optional[int] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    current_user: User = Depends(get_current_user),
) -> List[Forecast]:
    """
    Get forecasts with optional filtering
    """
    query = db.query(ForecastModel)
    
    if product_id:
        query = query.filter(ForecastModel.product_id == product_id)
    if start_date:
        query = query.filter(ForecastModel.date >= start_date)
    if end_date:
        query = query.filter(ForecastModel.date <= end_date)
    
    return query.order_by(ForecastModel.date).offset(skip).limit(limit).all()

@router.get("/{product_id}", response_model=List[Forecast])
def get_product_forecast(
    product_id: int,
    db: Session = Depends(get_db),
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    current_user: User = Depends(get_current_user),
) -> List[Forecast]:
    """
    Get forecasts for a specific product
    """
    query = db.query(ForecastModel).filter(ForecastModel.product_id == product_id)
    
    if start_date:
        query = query.filter(ForecastModel.date >= start_date)
    if end_date:
        query = query.filter(ForecastModel.date <= end_date)
    
    forecasts = query.order_by(ForecastModel.date).all()
    
    # Don't raise 404 if no forecasts exist, just return empty list
    # if not forecasts:
    #     raise HTTPException(
    #         status_code=status.HTTP_404_NOT_FOUND,
    #         detail="No forecasts found for this product"
    #     )
    
    return forecasts

@router.post("/generate", status_code=status.HTTP_202_ACCEPTED)
def generate_forecasts(
    forecast_params: ForecastGenerate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> Dict[str, Any]:
    """
    Trigger background task to generate new forecasts for products
    """
    try:
        # Add the forecast generation task to the background
        background_tasks.add_task(
            run_forecast_generation,
            db,
            forecast_params.product_ids,
            forecast_params.periods,
            forecast_params.frequency
        )
        
        return {
            "status": "accepted",
            "message": "Forecast generation started in the background."
        }
    
    except Exception as e:
        print(f"Error initiating forecast generation: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to start forecast generation: {str(e)}"
        )

@router.get("/prophet/forecast", response_model=List[Dict[str, Any]])
def get_prophet_forecast() -> List[Dict[str, Any]]:
    """
    Get forecast generated by Prophet
    """
    try:
        # Path to the forecast JSON file
        forecast_path = "/home/ubuntu/Resupply-forecast-app/data/forecast.json"
        
        # Check if forecast file exists
        if not os.path.exists(forecast_path):
            # If not, generate it
            input_csv = "/home/ubuntu/Resupply-forecast-app/data/cleaned_data.csv"
            
            # Read the CSV
            df = pd.read_csv(input_csv)
            
            # Filter for 'Actual sales'
            df_actual_sales = df[df["type"] == "Actual sales"].copy()
            
            # Prepare DataFrame for Prophet
            df_actual_sales["ds"] = pd.to_datetime(df_actual_sales["date"])
            df_actual_sales["y"] = df_actual_sales["value"]
            
            # Train Prophet model
            model = Prophet()
            model.fit(df_actual_sales)
            
            # Create future DataFrame for 12 months
            future = model.make_future_dataframe(periods=12, freq='M')
            
            # Forecast
            forecast = model.predict(future)
            
            # Extract relevant columns and convert to JSON
            forecast_output = forecast[["ds", "yhat"]].copy()
            forecast_output["ds"] = forecast_output["ds"].dt.strftime("%Y-%m-%d")
            
            # Save to JSON
            with open(forecast_path, "w") as f:
                json.dump(forecast_output.to_dict(orient="records"), f, indent=4)
        
        # Read the forecast from the JSON file
        with open(forecast_path, "r") as f:
            forecast_data = json.load(f)
        
        return forecast_data
    
    except Exception as e:
        print(f"Error getting Prophet forecast: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get Prophet forecast: {str(e)}"
        )

